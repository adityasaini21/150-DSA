ques ->https://leetcode.com/problems/longest-consecutive-sequence/description/

//Brute Force
//Time complexity: O(n^2)
//Space complexity: O(n)


public class Solution {
    public int longestConsecutive(int[] nums) {
        int res = 0;
        Set<Integer> store = new HashSet<>();
        for (int num : nums) {
            store.add(num);
        }

        for (int num : nums) {
            int streak = 0, curr = num;
            while (store.contains(curr)) {
                streak++;
                curr++;
            }
            res = Math.max(res, streak);
        }
        return res;
    }
}



//Sorting
//Time complexity: O(nlogn)
//Space complexity: O(n)

public class Solution {
    public int longestConsecutive(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        Arrays.sort(nums);
        int res = 0, curr = nums[0], streak = 0, i = 0;

        while (i < nums.length) {
            if (curr != nums[i]) {
                curr = nums[i];
                streak = 0;
            }
            while (i < nums.length && nums[i] == curr) {
                i++;
            }
            streak++;
            curr++;
            res = Math.max(res, streak);
        }
        return res;
    }
}



//HashMap
//Time complexity: O(n)
//Space complexity: O(n)
class Solution {
    public int longestConsecutive(int[] nums) {
        int longestLength = 0;
        Map<Integer, Boolean> map = new HashMap<>();

        for (int num : nums) {
            map.put(num, Boolean.FALSE);
        }

        for (int num : nums) {

            int currentLength = 1;
            //Check forward direction
            int nextNum = num + 1;
            while (map.containsKey(nextNum) && map.get(nextNum) == false) {
                currentLength++;
                map.put(nextNum, Boolean.TRUE);
                nextNum++;
            }

            //check reverse
            int prevNum = num - 1;
            while (map.containsKey(prevNum) && map.get(prevNum) == false) {
                currentLength++;
                map.put(prevNum, Boolean.TRUE);
                prevNum--;

            }
            longestLength = Math.max(longestLength, currentLength);

        }
        return longestLength;

    }
}
